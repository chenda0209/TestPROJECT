// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel GenerateGrass
#pragma kernel FrustumCulling
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"

struct GrassData
{
    float3 worldPos;    // 12 bytes
    float rotation;// 4 bytes (绕 Y 轴转一下就行)
    float scale;
};
RWStructuredBuffer<GrassData> _GrassDataBuffer; // 物体原始数据，StructuredBuffer只读，RWStructuredBuffer为可读写，AppendStructuredBuffer只写
StructuredBuffer<uint> _ActiveChunkIDsBuffer;
uint _ActiveChunkCount;

AppendStructuredBuffer<uint> _Lod0Buffer; // AppendStructuredBuffer 用于接收剔除后的结果
AppendStructuredBuffer<uint> _Lod1Buffer;
AppendStructuredBuffer<uint> _Lod2Buffer;

Texture2D<float4> _SplatMap;
Texture2D<float4> _HeightMap;
SamplerState LinearClampSampler; // 只要 C# 传了图，Unity 会自动处理采样器

uint _InstanceCount; // 一起实例化的总数量
float _TerrainHeight;

float4 _Threshold; // lod远近设置
float4 _FrustumPlanes[6];
float4 _CameraPos;

uint _TargetChunkID;     // Chunk的ID
float3 _ChunkBasePos;   // 这一块的左下角世界坐标 (如 32, 0, 64)
float3 _TerrainBasePos;

// 一个经典的基于坐标采样的随机函数
float GetRandom(float2 st)
{
    return frac(sin(dot(st.xy, float2(12.9898, 78.233))) * 43758.5453123);
}

[numthreads(8,8,1)]
void GenerateGrass (uint3 id : SV_DispatchThreadID)
{
    // 1. 索引计算 (1米4棵草，一行128个)
    uint index = id.y * 128 + id.x; 
    uint globalIdx = _TargetChunkID * 16384 + index;

    // 2. 计算世界坐标 (id.x 是 0~127，间距 0.25)
    float2 localOffset = id.xy * 0.25; 
    float3 worldPos = _ChunkBasePos + float3(localOffset.x, 0, localOffset.y);
    
    // 假设地形大小是 1024，请确保这里的 1024.0 和你实际地形尺寸一致
    float2 localPos = worldPos.xz - _TerrainBasePos.xz;
    float2 worldUV = localPos / 1024.0; 

    // 2. 采样高度图 (重点)
    // 即使定义为 float4，高度信息也依然在 r 通道
    float height = UnpackHeightmap(_HeightMap.SampleLevel(LinearClampSampler, worldUV, 0));
    
    // 计算实际世界高度：地形物体自身的Y轴位置 + (归一化高度 * 地形设定的最大高度)
    float worldY = _TerrainBasePos.y + (height * _TerrainHeight)*2;

    // 3. 采样权重图 (你之前的逻辑)
    float weight = _SplatMap.SampleLevel(LinearClampSampler, worldUV, 0).r;

    // 4. 应用随机抖动和生存判定
    float2 rand = float2(GetRandom(worldUV), GetRandom(worldUV + 1.5));
    float2 jitter = (rand - 0.5) * 0.25; 
    float survivalThreshold = GetRandom(worldUV + 3.14); 

    if (weight > survivalThreshold) 
    {
        // 最终坐标：Y轴使用刚算出来的 worldY
        _GrassDataBuffer[globalIdx].worldPos = float3(worldPos.x + jitter.x, worldY, worldPos.z + jitter.y);
        _GrassDataBuffer[globalIdx].rotation = GetRandom(worldUV + 7.7) * 6.2831;
        _GrassDataBuffer[globalIdx].scale = 0.8 + weight * 0.4; 

        _GrassDataBuffer[globalIdx].worldPos = float3(worldPos.x + jitter.x, worldY, worldPos.z + jitter.y);
    }
    else 
    {
        _GrassDataBuffer[globalIdx].scale = 0;
    }
}


[numthreads(64,1,1)]
void FrustumCulling (uint3 id : SV_DispatchThreadID)
{
    // 1. 确定当前线程正在处理“可见清单”中的第几个 Chunk
    // 假设 id.x 是从 0 增长到 (可见块数 * 16384)
    uint visibleChunkSeq = id.x / 16384; 
    
    // 安全检查：超过可见总数直接退
    if (visibleChunkSeq >= _ActiveChunkCount) return;

    // 2. 从任务清单获取这个块在大 Buffer 里的真实 Slot ID
    int realSlotID = _ActiveChunkIDsBuffer[visibleChunkSeq];
    
    // 3. 计算这棵草在该 Chunk 内部的偏移
    uint grassIdxInChunk = id.x % 16384;

    // 4. 算出这棵草在 _GrassDataBuffer (全量大 Buffer) 中的最终位置
    uint index = (uint)realSlotID * 16384 + grassIdxInChunk;

    // 5. 读取数据
    GrassData grass = _GrassDataBuffer[index];
    if (grass.scale <= 0) return;
    // 剔除所需数据
    float4 center = float4(grass.worldPos, 1); // 包围球中心 (x, y, z)
    float radius = 1;  // 包围球半径 (r)
    bool isVisible = true;
    // 2. 实现包围球视锥体剔除 (Sphere-Frustum Culling)

    for (int i = 0; i < 6; i++)
    {
        float4 plane = _FrustumPlanes[i];
        // 计算点到平面的有符号距离：Ax + By + Cz + D
        // 注意：这里我们使用 float4(x, y, z, 1.0) 和 Plane(A, B, C, D) 的点积
        float distance = dot(plane, center); 
        // 如果 距离 < -半径，则整个球体都在平面外部
        // distance + radius < 0.0 是更常见的写法
        if (distance < -radius) 
        {
            isVisible = false;
            break; // 发现一个不可见平面，立即停止检查
        }
    }
    
    if (isVisible)
    {
        // 如果可见，将这个实例的原始索引写入 Append Buffer
        // _VisibleIndexBuffer.Append(index);
        //进阶版本，根据远近使用不同的shader绘制
        float3 diff = center.xyz - _CameraPos.xyz;
        float distSq = dot(diff, diff); // 距离的平方，省去了开方运算

        if (distSq < _Threshold.x * _Threshold.x)
        { 
            // 近处物体
            _Lod0Buffer.Append(index);
        }
        else if(distSq < _Threshold.y * _Threshold.y )
        {
            // 远处物体
            _Lod1Buffer.Append(index);
        }
        else if (distSq < _Threshold.z * _Threshold.z)
        {
            _Lod2Buffer.Append(index);
        }
    }
}
