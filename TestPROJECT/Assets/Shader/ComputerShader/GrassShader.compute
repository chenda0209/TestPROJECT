// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel GenerateGrass
#pragma kernel FrustumCulling


uint _InstanceCount; // 一起实例化的总数量

Texture2D<float4> _SplatMap;
SamplerState sampler_SplatMap; // 只要 C# 传了图，Unity 会自动处理采样器

struct GrassData
{
    float3 worldPos;    // 12 bytes
    float rotation;// 4 bytes (绕 Y 轴转一下就行)
    float scale;
};
// 物体原始数据，StructuredBuffer只读，RWStructuredBuffer为可读写，AppendStructuredBuffer只写
RWStructuredBuffer<GrassData> _GrassDataBuffer;
// AppendStructuredBuffer 用于接收剔除后的结果
AppendStructuredBuffer<uint> _lod0Buffer;
AppendStructuredBuffer<uint> _lod1Buffer;
AppendStructuredBuffer<uint> _lod2Buffer;

float4 _Threshold; // lod远近设置
float4 _FrustumPlanes[6];
float4 _CameraPos;


uint _TargetSlotID;     // 货架号
float3 _ChunkBasePos;   // 这一块的左下角世界坐标 (如 32, 0, 64)

// 一个经典的基于坐标采样的随机函数
float GetRandom(float2 st)
{
    return frac(sin(dot(st.xy, float2(12.9898, 78.233))) * 43758.5453123);
}

[numthreads(8,8,1)]
void GenerateGrass (uint3 id : SV_DispatchThreadID)
{
    // 1. 索引计算 (1米4棵草，一行128个)
    uint index = id.y * 128 + id.x; 
    uint globalIdx = _TargetSlotID * 16384 + index;

    // 2. 计算世界坐标 (id.x 是 0~127，间距 0.25)
    float2 localOffset = id.xy * 0.25; 
    float3 worldPos = _ChunkBasePos + float3(localOffset.x, 0, localOffset.y);

    // 3. 计算 UV (直接用世界坐标 / 地形大小)
    // 假设地形是 1024x1024，坐标在 0~1024 之间
    float2 worldUV = worldPos.xz / 1024.0;

    // 4. 采样与抖动 (逻辑不变)
    float weight = _SplatMap.SampleLevel(sampler_SplatMap, worldUV, 0).r;
    
    // 抖动：最大偏移 0.25 (即一个格子的宽度)
    float2 rand = float2(GetRandom(worldUV), GetRandom(worldUV + 1.5));
    float2 jitter = (rand - 0.5) * 0.25; 

    float survivalThreshold = GetRandom(worldUV + 3.14); 
    
    if (weight > survivalThreshold) 
    {
        _GrassDataBuffer[globalIdx].worldPos = worldPos + float3(jitter.x, 0, jitter.y);
        _GrassDataBuffer[globalIdx].rotation = GetRandom(worldUV + 7.7) * 6.2831;
        _GrassDataBuffer[globalIdx].scale = 0.8 + weight * 0.4; 
    }
    else 
    {
        _GrassDataBuffer[globalIdx].scale = 0;
    }
}


[numthreads(64,1,1)]
void FrustumCulling (uint3 id : SV_DispatchThreadID)
{
    uint index = id.x;
    
    // 将 3D 线程 ID 映射到 1D 实例索引
    // uint index = id.x + id.y * 8 + id.z * (8 * 8); // 假设您使用 8x8x1 线程组
    if (index >= _InstanceCount)
    {
        return; // 防止越界
    }

    // 1. 获取当前实例的数据
    GrassData grass = _GrassDataBuffer[index];

    // 提前剔除
    if (grass.scale <= 0) return;
    // 剔除所需数据
    float4 center = float4(grass.worldPos,1); // 包围球中心 (x, y, z)

    float radius = 0.5f;       // 包围球半径 (r)
    
    bool isVisible = true;
    
    // 2. 实现包围球视锥体剔除 (Sphere-Frustum Culling)
    for (int i = 0; i < 6; i++)
    {
        float4 plane = _FrustumPlanes[i];
        
        // 计算点到平面的有符号距离：Ax + By + Cz + D
        // 注意：这里我们使用 float4(x, y, z, 1.0) 和 Plane(A, B, C, D) 的点积
        float distance = dot(plane, center); 
        
        // 如果 距离 < -半径，则整个球体都在平面外部
        // distance + radius < 0.0 是更常见的写法
        if (distance < -radius) 
        {
            isVisible = false;
            break; // 发现一个不可见平面，立即停止检查
        }
    }
    
    if (isVisible)
    {

        // 如果可见，将这个实例的原始索引写入 Append Buffer
        // _VisibleIndexBuffer.Append(index);
        //进阶版本，根据远近使用不同的shader绘制
        float3 diff = center.xyz - _CameraPos.xyz;
        float distSq = dot(diff, diff); // 距离的平方，省去了开方运算

        if (distSq < _Threshold.x * _Threshold.x)
        { 
            // 近处物体
            _lod0Buffer.Append(index);
        }
        else if(distSq < _Threshold.y * _Threshold.y )
        {
            // 远处物体
            _lod1Buffer.Append(index);
        }
        else if (distSq < _Threshold.z * _Threshold.z)
        {
            _lod2Buffer.Append(index);
        }
    }

}
